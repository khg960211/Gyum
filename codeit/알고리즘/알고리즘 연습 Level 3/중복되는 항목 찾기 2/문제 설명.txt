(N + 1)의 크기인 리스트에, 1부터 N까지의 임의의 자연수가 요소로 할당되어 있습니다. 그렇다면 어떤 수는 꼭 한 번은 반복되겠지요.

예를 들어 [1, 3, 4, 2, 5, 4]와 같은 리스트 있을 수도 있고, [1, 1, 1, 6, 2, 2, 3]과 같은 리스트가 있을 수도 있습니다. (몇 개의 수가 여러 번 중복되어 있을 수도 있습니다.)

이러한 리스트에서 반복되는 요소를 찾아내려고 합니다.

중복되는 어떠한 수 ‘하나’만 찾아내도 됩니다. 즉 [1, 1, 1, 6, 2, 2, 3]의 예시에서 1, 2를 모두 리턴하지 않고, 1 또는 2 하나만 리턴하게 하면 됩니다.

저번 과제에서는 사전을 정의해서 문제를 푸는 방법을 사용했는데요, 이번 과제에서는 두 가지의 제약이 있습니다.

1. O(n) 이상의 공간을 사용할 수 없습니다. 즉 사전이나 리스트와 같이 인풋 리스트의 길이에 비례하는 공간 저장 도구를 사용할 수 없습니다!
2. 인풋으로 받는 리스트 some_list의 요소들을 바꾸거나 변형할 수 없습니다.

전에 풀었던 같은 문제를 다른 제약들이 걸려 있는 상황에서 풀어보세요.

힌트 1.
이진 탐색 알고리즘 기억나시나요?

정렬된 리스트에서 특정 값을 찾고 싶을 때 리스트의 탐색 범위를 반씩 줄여나가면서 리스트 안에 값이 있는지 확인하는 알고리즘인데요.

이진 탐색과 비슷하게 중복되는 요소 탐색 범위를 반씩 줄여나갈 수 있는 방식이 있는지 한 번 고민해보세요.

힌트 2.
number_array = [1, 2, 4, 6, 2, 5, 3] 이 리스트를 인풋이라고 생각해봅시다. 길이가 7인 리스트에 1부터 6까지의 자연수들이 들어있는데요. 중복되는 요소가 1부터 3까지의 범위에 있는지 4부터 6까지의 범위에 있는지 알 수 있는 방법을 생각해보세요.


힌트 3.
다시 number_array = [1, 2, 4, 6, 2, 5, 3] 를 살펴봅시다.

리스트 안에 숫자는 7개고 이 7개의 숫자가 1 ~ 6까지의 자연수일 수 있으니까 범위 1 ~ 3에 있는 숫자가 4개 이상이거나 범위 4 ~ 6에 있는 숫자가 4개 이상일 수밖에는 없겠죠?

(두 범위가 모두 4보다 작은 것은 말이 안 되죠. 숫자는 7개이고 1 ~ 3인 숫자가 3개 이하고 4 ~ 6인 숫자도 3개 이하면 절대 총 숫자가 7개가 될 수 없기 때문입니다.)

그럼 1 ~ 3 범위에 속하는 숫자가 4개 이상이라면 1 ~ 3 범위에는 적어도 한 숫자는 다시 반복되는 요소일 수밖에 없겠네요. 숫자는 4개인데 요소가 될 수 있는 자연수는 1, 2, 3 세 개밖에는 없으니까요. 반대로 4 ~ 6 범위에 속하는 숫자가 4개 이상일 때도 동일합니다.

기존 탐색 범위를 1~6에서 1~3 또는 4~6로 줄일 수 있군요! 범위를 계속 줄이면 결국 답을 찾을 수 있겠죠?

힌트 4.
아직 좀 이해하시기 힘드시다면, 실제로 반복되는 숫자를 찾는 예시를 통해 차근차근 알아봅시다.

number_array = [1, 2, 4, 6, 2, 5, 3] 일 경우를 생각해봅시다.

1 ~ 3 범위에 있는 자연수의 갯수: 4개, 4 ~ 6 범위에 있는 자연수의 갯수: 3개
→ 1 ~ 3 범위에 반복되는 자연수가 있을 수밖에 없다.

1 범위에 있는 자연수의 갯수: 1개, 2 ~ 3 범위에 있는 자연수의 갯수: 3개
→ 2 ~ 3 범위에 반복되는 자연수가 있을 수밖에 없다

2 범위에 있는 자연수의 갯수: 2개 → 반복되는 숫자 2을 찾았다 (끝)
이런 식으로 반복되는 숫자를 찾을 수 있습니다!

위 방식대로 반복되는 숫자를 찾는 코드를 써볼까요?


시간 복잡도
인풋 리스트의 길이를 n이라고 했을 때, 탐색 범위를 줄일 때마다 리스트의 모든 요소 n개를 돌면서 두 개의 범위 안에 있는 자연수의 갯수를 세고 있습니다. 한 번 리스트를 돌 때마다 시간 복잡도는 O(n)입니다.

범위의 크기는 (n−1)/2에서 시작해서 계속 반으로 줄어듭니다. 최악의 경우 범위가 자연수 하나가 되는 데까지 O(lg(n))가 걸리죠.

범위가 줄어들 때마다 O(n)의 작업을 하고, 범위는 최악의 경우 총 O(lg(n))번 줄어들기 때문에 최종 시간 복잡도는 O(nlg(n))이 됩니다.