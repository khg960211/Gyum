문제를 Divide and Conquer 방식으로 풀어볼 텐데요. 시간 복잡도는 O(nlgn)이 되어야 합니다.

이번 sublist_max 함수는 3개의 파라미터를 받습니다.

profits: 며칠 동안의 수익이 담겨 있는 리스트
start: 살펴볼 구간의 시작 인덱스
end: 살펴볼 구간의 끝 인덱스
sublist_max는 profits의 start부터 end까지 구간에서 가능한 가장 큰 수익을 리턴합니다.

합병 정렬을 구현할 때 merge_sort 함수를 깔끔하게 작성하기 위해 추가로 merge 함수를 작성했던 것 기억 나시나요? 
마찬가지로 퀵 정렬을 구현할 때 quicksort 함수에 추가로 partition 함수를 작성했습니다. 
이번에도 sublist_max 함수에 추가로 새로운 함수를 작성하면 도움이 되실 겁니다.


test_list = [-2, -3, 4, -1, -2, 1, 5, -3]
sublist_max(test_list, 0, 7)
위 예시에서, 정답 구간은 어디에 있을까요?

크게 세 가지 가능성이 있습니다.

정답 구간이 왼쪽 반 어딘가에 있다.
정답 구간이 오른쪽 반 어딘가에 있다.
정답 구간이 중앙을 관통한다. 즉, 왼쪽 반에서 가장 오른쪽에 있는 -1과 오른쪽 반에서 가장 왼쪽에 있는 -2가 포함된다.
셋 중 가장 큰 결과값이 이 문제의 정답이 되겠네요.

Divide and Conquer의 관점에서 살펴보면 이렇습니다.

Divide: 구간을 왼쪽 반과 오른쪽 반으로 나눈다.
Conquer: 왼쪽 반에서 가능한 최대 수익과 오른쪽 반에서 가능한 최대 수익을 각각 계산한다.
Combine: 왼쪽 반에서 가능한 최대 수익, 오른쪽 반에서 가능한 최대 수익, 중앙을 관통하면서 가능한 최대 수익을 비교해서 그 중 가장 큰 값을 고른다.